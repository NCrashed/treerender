module treerender.geometry.octomesh;

import treerender.math.vector;
import treerender.geometry.greedy;
import treerender.geometry.mesh;
import treerender.geometry.octo;
import treerender.geometry.voxel;
import treerender.geometry.color;

struct VoxelNode(T = Color, size_t n = 16, Primitive prim = Primitive.triangles) if(isVoxel!T) {
  Voxels!(T, n) voxels;
  Mesh!(T, prim) mesh;

  alias This = VoxelNode!(T, n, prim);

  /// Iterate over all indecies of voxel grid and assign given value to it.
  static This generate(T delegate(v3s) f) {
    This ret;
    foreach(x; 0..n) {
      foreach(y; 0..n) {
        foreach(z; 0..n) {
          ret.voxels[x, y, z] = f(v3s(x, y, z));
        }
      }
    }
    return ret;
  }

  /// Regenerate triangles for current voxels
  void triangulate() {
    mesh = greedyTriangulate!(prim, T, n)(voxels);
  }

  /// Blend voxels, no mesh generated by default.
  This blend(This other) {
    This ret;
    ret.voxels = this.voxels.blend(other.voxels);
    return ret;
  }
}

alias OctoMesh(T = Color, size_t n = 16, Primitive prim = Primitive.triangles)
  = OctoTree!(VoxelNode!(T, n, prim));

/// Procedural generation of octo tree with mesh
OctoMesh!(T, n, prim) octoProcedural(T, size_t n, Primitive prim)(size_t maxDepth, T delegate(v3f) gen) {
  return OctoMesh!(T, n, prim).generate(
    (c) => c.depth >= maxDepth ? GenCheck.generate : GenCheck.deeper,
    (c) {
      auto start = c.cubeStart;
      auto size = c.gridSize;
      return VoxelNode!(T, n, prim).generate((v) => gen(start + cast(v3f)v / size));
    },
    (a, b) => a.blend(b)
    );
}
